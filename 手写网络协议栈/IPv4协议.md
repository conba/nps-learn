# IPv4协议

# 1. IPv4 的基本概念

* IPv4是一个网络层协议，用于通过IP地址表示网络中的设备，并确保数据包能够从源设备正确传输到目标设备
* IPv4是一种**无连接**协议，意味着它不保证数据包的传输成功，顺序或可靠性。传输的可靠性依赖上层协议（TCP）
* IPv4地址采用了32位地址空间，可以提供约43亿个地址（具体是4294967296个）

# 2. IPv4地址表示

IPv4采用点分十进制表示：10.10.10.1

IPv4地址结构可以分为三个部分：

* 网络部分：用于标识网络地址

* 主机部分：用于标识主机设备

* 子网掩码：用来区分网络部分和主机部分的边界

  ```
  1  192.168.0.1
  2  |   |   |   |
  3  |   |   |   |-- 第四个字节（1）
  4  |   |   |------ 第三个字节（0）
  5  |   |---------- 第二个字节（168）
  6  |-------------- 第一个字节（192）
  ```

  IPv4可以拆分成两个部分，如果从**192.168.0**拆分，前**24**位都是**网络部分**，后**8**位为**主机部分**。拆分方法由子网掩码决定。这样的拆分方法子网掩码是**255.255.255.0**

# 3. IPv4地址分类

* **A类地址（Class A）**

  地址范围：**0.0.0.0** 到 **127.255.255.255**

  主要用于大型网络，提供大量的主机地址。网络部分占用一个字节，主机部分占用3个字节

  如10.0.0.0（私有地址）

* **B类地址（Class B）**

  地址范围：**128.0.0.0** 到 **191.255.255.255**

  适用于中等规模的网络。网络部分赵勇2个字节，主机部分占用两个字节

  如：**172.16.0.0**

* **C类地址（Class C）**

  地址范围：**192.0.0.0** 到 **223.255.255.255**

  适用于小型网络，网络部分占3个字节，主机部分占用一个字节

* **D类地址（Class D）**

  地址范围：**224.0.0.0** 到 **239.255.255.255**

  用于多播，即数据包发送到多个主机

* **E类地址（Class E）**

  地址范围：**240.0.0.0** 到 **255.255.255.255**

  保留地址，通常不用于常规的互联网通信。

# 4. 子网划分与子网掩码

为了有效地利用IP地址空间，IPv4网络会进行子网划分。子网掩码用于区分IP地址中的网络部分和主机部分。

例如 IP **192.168.0.1** 和子网掩码 **255.255.255.0**。掩码指示前**24**位网络部分，后**8**位是主机部分。

通过子网掩码，可以将一个大的网络分成多个小的子网，检查地址浪费，提高网络效率。

## IP报文结构

![](image\ipv4报文.png)

**IP数据包要求以4字节对齐**

![](image\IPv4协议.svg)

## 1. IPv4数据包结构

**IPv4数据包由两部分组成：**

* IP头：包含了IP协议所需要的各种控制信息
* 数据部分：即上层协议（如TCP，UDP）的数据

**IPv4数据包头部结构**

| 字段                                 | 长度（bit） | 描述                                                         |
| ------------------------------------ | ----------- | ------------------------------------------------------------ |
| 版本（Version）                      | 4（位）     | 只是IP协议版本，IPv4为4                                      |
| 头部长度（IHL）                      | 4           | 表示IP头部的长度，单位是32位字（3字节）                      |
| 服务类型（Type of Service）          | 8           | 定义数据包的优先级与服务质量（Qos）                          |
| 总长度（Total Length）               | 16          | 数据包的总长度，包括头部和数据部分                           |
| 标识符（Identification）             | 16          | 唯一表示数据包，用于数据包的分片和重组                       |
| 标志（Flags）                        | 3           | 控制数据包分片的行为（如是否允许分片）                       |
| 片偏移（Fragment Offset）            | 13          | 数据包分片的位置偏移量                                       |
| TTL（Time to Live）                  | 8           | 数据包的最大跳数，防止数据包在网络中无线循环**（给数据包一个生命值）**， TTL≈128：windows, TTL≈64: linux |
| 协议（Protocol）                     | 8           | 上层协议，表示数据部分使用的协议（如TCP = 6，UDP=17）        |
| 头部校验和（Header Checksum）        | 16          | 用于检验头部是否在传输过程中损坏                             |
| 源IP地址（Source IP Address）        | 32          | 数据包发送者的IP地址                                         |
| 目标IP地址（Destination IP Address） | 32          | 数据包接受者的IP地址                                         |
| 选项（Options）                      | 可选部分    | 可选字段，包括路由选择，时间戳等高级功能                     |
| 填充（Padding）                      | 可选部分    | 填充字节，确保数据包头的长度是32位字的倍数                   |
| 数据部分（Data）                     | 可变长度    | 上层协议的数据，如TCP或UDP的数据部分                         |

## 2. IPv4的数据传输过程

IPv4的传输过程是通过路由器根据目标IP地址来转发数据包的。每个路由器查看数据包的目标IP地址，决定下一个跳点，知道数据包到达目标设备。具体步骤如下

1. 源设备生成数据包，添加目的地的IPv4地址
2. 路由器根据路由表决定数据包的转发路径。
3. 数据包在网络中可能经过多个路由器
4. 目标设备接受到数据包后，根据目标IP地址处理数据。

# 5. 字段解析

## 1. TTL

​	TTL是Time to live的缩写，表示生存时间。

## 1.1. TTL的作用

​	TTL字段用于限制IP数据包在网络中的存活时间，防止数据包在路由环路中无限循环，从而保护网络资源。

* 每当数据包经过一个路由器的时候，TTL值就会减1.
* 当TTL值减到0时，路由器会丢弃该数据包，并向发送方发送一个ICPM超时报文，通知其数据包未能到达目的地。

### 1.2. TTL应用

```shell
ping www.baidu.com

tracert www.baidu.com
```

![](image\tracert.png)

## 2. Flag

​	Flag 字段是3位长，用于控制分片过程。各位的含义如下。

## 2.1. 第1位（保留位）：

* 保留，固定位0，未使用

## 2.2. 第2位（DF，Don't Fragment，禁止分片）：

* 1：表示不允许分片。如果数据报超过MTU且无法分片，路由器会丢弃改数据包并发送一个ICMP错误消息给发送方。
* 0： 允许分片

## 2.3. 第3位（MF，More Fragment，更多分片）：

* 1： 表示后面还有更多的分片
* 0： 表示这是最后一个分片

## 3. Fragment Offset

​	Fragment Offset 字段为13位，表示当前分片相对于原始数据包的起始位置（**以8字节为单位**）。这是因为IP数据包分片时，**片段必须是8字节的倍数（除了最后一个分片）**。

​	当接收方收到所有分片时，根据Fragment Offset的值和分片的长度，将分片数据重新组装成完整的IP数据报。

## 4. 分片工作流程

![](image\数据包分片.svg)

| 在IPv4首部中，Flag（标志）和Fragment Offset（片段偏移）字段用于实现IP数据包的分片和重组功能。这是为了在不同的网络链路上传输数据时，适应链路的最大传输单元（MTU，Maximum Transmissiion Unit）.

## 4.1. 发送数据：

​		当数据包超过链路的MTU时，路由器会将其分片，**并且不保证能够按顺序发送和接收**，每个分片都有独立的IPv4首部，带有共同的标识符（Identification字段），使用Flag, Fragment Offset, Identification共同来决定一个包的重组顺序。

## 4.2. 标志字段控制：

* 如果DF标志设置为1，且数据包大小超过MTU，路由器会丢弃数据包，并发送ICPM报文
* 如果DF标志位0，则允许分片

## 4.3. 设置偏移：

​		每个分片的Fragment Offset 字段根据其在原始数据报中的位置计算，确保接收方能够按照顺序重组数据。

## 4.4. 接收和重组：

* 接收方通过标识符（Identification字段）将分片归为同一个数据报
* 根据Fragment Offset的值和MF标志位，判断数据是否接收完整。
* 一旦所有分片接收完成，数据报被重组并交付给上层协议

## 5. Checksum

IPv4首部的Checksum字段用于检测IP首部在传输过程中是否出现错误。这是一种基本的错误检测机制，帮助确保数据的完整性。

* 仅校验IP首部：

  不包含数据部分（Payload）

* 工作原理

  发送方计算首部的校验和，并填入Checksum字段；接收方重新计算校验和并与该字段对比。如果不一致，说明首部在传输过程中发生了错误，数据包将被丢弃。

* **计算时需要将*checksum*字段设置位0x0000**

## 5.1. 计算方式.

校验和是通过对IP首部中的16位字进行计算得到的。以下时步骤：

1. 将首部看作**16位**的**单元**序列：

   把IPv4首部划分成多个16位的部分（以**2字节为单位**）。如果字节数是奇数，需要在最后填充一个字节的0.

2. 对所有16为单元求和。

   用**二进制补码加法**对这些16位单元逐个求和。如果假发中产生进位（溢出），将进位加回到结果的低位。

3. 对结果取反

   将求和结果按位取反（即把1变为0，0变为1），得到的值即为校验和。

4. 填入Checksum字段：

   将计算出的校验和写入IPv4首部的Checksum字段。

5. 接收端校验：

   接收方也按照上述方式计算校验和，并将计算结果与Checksum字段对比：

   若结果全为1（即无误），数据包被接收。

   若结果不全为1，则数据包存在错误，会被丢弃。

## 5.2. 示例

假设IPv4首部包含以下16位单元（以十六进制表示）：

```
4500 003c 1c46 4000 4006 b1e6 c0a8 0001 c0a8 00c7
```

计算步骤

1. 求和：

   ```
   4500 + 003c + 1c46 + 4000 + 4006 + b1e6 + c0a8 + 0001 + c0a8 + 00c7 = 1b861(进位)
   ```

2. 处理进位，将进位（高16位）加到低16位

   ```
   0001 b861 -> 0b861 + 0001 = b862
   ```

3. 按位取反

   ```
   b862  ->  479d
   ```

4. 校验和

   最终校验和是479d，填入Checksum字段。

## 5.3. 特点

##  5.3.1. 特点

* 快速，适用于硬件实现。
* 对单比特错误和偶数个比特翻转错误有效。

## 5.3.2. 局限性

* 仅对IP首部检测，数据部分的完整性有上层协议（如TCP/UDP的校验和）负责
* 对都写复杂错误（如比特错位）无法检测。

## 6. 以太网包长度限制

以太网数据包的最大长度通常取决于以太网的类型和标准。对于传统的以太网（Ethernet II）：

## 6.1. 最大帧长度：1518字节，其中包括：

* 前导码（Preamble）：8字节
* 起始帧定界符（SFD）：1字节
* 以太网头部（Ethernet Header）：14字节（包含目的地址、源地址和类型字段）
* 数据（Payload）:46至1500字节（优效负载）
* CRC校验和：4字节

所以，数据部分的最大长度位1500字节。加上以太网头部和CRC校验和，总长度为1518字节。







